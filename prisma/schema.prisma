generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String    @id @default(uuid())
  email                String    @unique
  password             String
  role                 String // "Patient" | "Medecin" | "Admin"
  firstName            String?
  lastName             String?
  gender               String?
  address              String?
  phoneNumber          String?
  socialSecurityNumber String?   @unique
  dateOfBirth          DateTime?
  bloodType            String?
  allergies            String?
  medicalHistory       String?
  numeroOrdre          String?
  speciality           String?
  hospital             String?
  weight               String?
  height               String?
  bloodPressure        Json? // { systolic: string, diastolic: string }
  heartRate            String?
  oxygen               String?
  temperature          String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Relations pour les patients
  rendezVousAsPatient  RendezVous[] @relation("PatientRendezVous")
  consultationsAsPatient Consultation[] @relation("PatientConsultations")
  notificationsAsPatient Notification[] @relation("NotificationPatient")
  resultsAsPatient     Result[] @relation("PatientResults")

  // Relations pour les médecins
  rendezVousAsMedecin  RendezVous[] @relation("MedecinRendezVous")
  consultationsAsMedecin Consultation[] @relation("MedecinConsultations")
  notificationsAsMedecin Notification[] @relation("NotificationMedecin")
  resultsCreated       Result[] @relation("MedecinResults")
  sharedResults        Result[] @relation("SharedResults")

  // ✅ Relations ajoutées
  patientAccessRequests AccessRequest[] @relation("PatientAccessRequests")
  medecinAccessRequests AccessRequest[] @relation("MedecinAccessRequests")
}

model RendezVous {
  id                 String   @id @default(uuid())
  patientId          String
  patient            User     @relation("PatientRendezVous", fields: [patientId], references: [id])
  medecinId          String  // Médecin assigné au rendez-vous
  medecin            User?    @relation("MedecinRendezVous", fields: [medecinId], references: [id])
  date               DateTime
  location           String?
  status             String   @default("En attente") // "En attente", "Confirmé", "Rejeté", "Terminé"
  isTeleconsultation Boolean  @default(false)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}

model Consultation {
  id         String   @id @default(uuid())
  patientId  String
  patient    User     @relation("PatientConsultations", fields: [patientId], references: [id])
  medecinId  String   // Seul un médecin peut créer une consultation
  medecin    User     @relation("MedecinConsultations", fields: [medecinId], references: [id])
  date       DateTime
  summary    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Notification {
  id        String       @id @default(uuid())
  message   String
  date      DateTime     @default(now())
  read      Boolean      @default(false)
  type      String       // Changé pour "general" comme valeur par défaut
  relatedId String?      @unique// Supprimez @unique si plusieurs notifications par AccessRequest sont possibles
  patientId String?
  patient   User?        @relation("NotificationPatient", fields: [patientId], references: [id])
  medecinId String?
  medecin   User?        @relation("NotificationMedecin", fields: [medecinId], references: [id])
  accessRequest AccessRequest? @relation("NotificationAccessRequest", fields: [relatedId], references: [id])
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
}


model Result {
  id          String   @id @default(uuid())
  patientId   String
  patient     User     @relation("PatientResults", fields: [patientId], references: [id])
  createdById String // Seul un médecin peut créer un résultat
  createdBy   User     @relation("MedecinResults", fields: [createdById], references: [id])

  type         String
  date         DateTime
  description  String?
  fileUrl      String?
  documentHash String?
  isShared     Boolean  @default(false)

  sharedWithId String?
  sharedWith   User?   @relation("SharedResults", fields: [sharedWithId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ✅ Relation ajoutée pour BlockchainTransaction
  blockchainTransactions BlockchainTransaction[]
}

model AccessRequest {
  id         String       @id @default(uuid())
  status     String       @default("En attente")
  patientId  String
  medecinId  String
  patient    User         @relation("PatientAccessRequests", fields: [patientId], references: [id])
  medecin    User         @relation("MedecinAccessRequests", fields: [medecinId], references: [id])

  notification Notification? @relation("NotificationAccessRequest")

  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
}


model BlockchainTransaction {
  id              String   @id @default(uuid())
  relatedResultId String   @unique
  transactionHash String
  result          Result   @relation(fields: [relatedResultId], references: [id])
  createdAt       DateTime @default(now())
}