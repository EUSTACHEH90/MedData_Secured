generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String    @id @default(uuid())
  email                String    @unique
  password             String
  role                 String // "Patient" | "Medecin" | "Admin"
  firstName            String?
  lastName             String?
  gender               String?
  address              String?
  phoneNumber          String?
  socialSecurityNumber String?   @unique
  dateOfBirth          DateTime?
  bloodType            String?
  allergies            String?
  medicalHistory       String?
  numeroOrdre          String?
  speciality           String?
  hospital             String?
  weight               String?
  height               String?
  bloodPressure        Json? // { systolic: string, diastolic: string }
  heartRate            String?
  oxygen               String?
  temperature          String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Relations pour les patients
  rendezVousAsPatient  RendezVous[] @relation("PatientRendezVous")
  consultationsAsPatient Consultation[] @relation("PatientConsultations")
  notificationsAsPatient Notification[] @relation("NotificationPatient")
  resultsAsPatient     Result[] @relation("PatientResults")

  // Relations pour les médecins
  rendezVousAsMedecin  RendezVous[] @relation("MedecinRendezVous")
  consultationsAsMedecin Consultation[] @relation("MedecinConsultations")
  notificationsAsMedecin Notification[] @relation("NotificationMedecin")
  resultsCreated       Result[] @relation("MedecinResults")
  sharedResults        Result[] @relation("SharedResults")

  // ✅ Relations ajoutées
  patientAccessRequests AccessRequest[] @relation("PatientAccessRequests")
  medecinAccessRequests AccessRequest[] @relation("MedecinAccessRequests")
}

model RendezVous {
  id                 String   @id @default(uuid())
  patientId          String
  patient            User     @relation("PatientRendezVous", fields: [patientId], references: [id])
  medecinId          String  // Médecin assigné au rendez-vous
  medecin            User?    @relation("MedecinRendezVous", fields: [medecinId], references: [id])
  date               DateTime
  location           String?
  status             String   @default("En attente") // "En attente", "Confirmé", "Rejeté", "Terminé"
  isTeleconsultation Boolean  @default(false)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}

model Consultation {
  id         String   @id @default(uuid())
  patientId  String
  patient    User     @relation("PatientConsultations", fields: [patientId], references: [id])
  medecinId  String   // Seul un médecin peut créer une consultation
  medecin    User     @relation("MedecinConsultations", fields: [medecinId], references: [id])
  date       DateTime
  summary    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Notification {
  id            String       @id @default(uuid())
  message       String
  date          DateTime     @default(now())
  read          Boolean      @default(false)
  type          String       // "accessRequest" | "accessResponse" | "appointment" | ...
  target        String       // "Patient" | "Medecin"
  relatedId     String?      // FK -> AccessRequest.id (plus d'@unique ici)
  patientId     String?
  patient       User?        @relation("NotificationPatient", fields: [patientId], references: [id])
  medecinId     String?
  medecin       User?        @relation("NotificationMedecin", fields: [medecinId], references: [id])

  // ⚠️ on autorise plusieurs notifs par accessRequest
  accessRequest AccessRequest? @relation("NotificationAccessRequest", fields: [relatedId], references: [id], onDelete: SetNull)

  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  // --- Index & contrainte composite recommandés ---
  @@index([relatedId])
  @@index([patientId, target, read])
  @@index([medecinId, target, read])
  @@unique([relatedId, type, target]) // idempotence par (accessRequest, type, cible)
}



model Result {
  id          String   @id @default(uuid())
  patientId   String
  patient     User     @relation("PatientResults", fields: [patientId], references: [id])
  createdById String // Seul un médecin peut créer un résultat
  createdBy   User     @relation("MedecinResults", fields: [createdById], references: [id])

  type         String
  date         DateTime
  description  String?
  fileUrl      String?
  documentHash String?
  isShared     Boolean  @default(false)

  sharedWithId String?
  sharedWith   User?   @relation("SharedResults", fields: [sharedWithId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ✅ Relation ajoutée pour BlockchainTransaction
  blockchainTransactions BlockchainTransaction[]
  blockchainVerified Boolean? // ✅ Nouveau champ ajouté
  blockchainVerifiedAt DateTime?
  
}

model AccessRequest {
  id         String       @id @default(uuid())
  status     String       @default("En attente")
  patientId  String
  medecinId  String
  patient    User         @relation("PatientAccessRequests", fields: [patientId], references: [id])
  medecin    User         @relation("MedecinAccessRequests", fields: [medecinId], references: [id])
  motif     String?  // <-- motif libre
  notifications Notification[] @relation("NotificationAccessRequest")


  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
}


model BlockchainTransaction {
  id              String   @id @default(uuid())
  relatedResultId String   @unique
  transactionHash String
  transactionId   String?
  status           String?       
  error            String?      
  result          Result   @relation(fields: [relatedResultId], references: [id])
  createdAt       DateTime @default(now())

}


enum Scope {
  RESULTS
  ORDONNANCES
  TESTS
  ALL
}

model AccessGrant {
  id          String   @id @default(uuid())
  patientId   String
  medecinId   String
  scope       Scope
  resourceIds String[] @default([]) // liste précise optionnelle (sinon scope global)
  expiresAt   DateTime
  revoked     Boolean  @default(false)
  reasonHash  String?  // hash (SHA-256) du motif
  accessRequestId String?  @unique
  onChainKey  String?  // clé composite renvoyée/utilisée côté Fabric ("grant:patientId:medecinId:grantId")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
